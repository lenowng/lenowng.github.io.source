import React from 'react';
import BlogPostLayout from '../../layouts/BlogPostLayout';

const ArchitecturePost: React.FC = () => {
  return (
    <BlogPostLayout
      title="The Invisible Engine: How Nightr.dev is Architected & Orchestrated"
      date="2024-02-10"
      readTime="12 min read"
      tags={['Architecture', 'React', 'DevOps']}
    >
      <p>I built this platform not just as a portfolio, but as a proof-of-concept for the "Systems Thinking" I apply to every project. This isn't just a static HTML page; it's a fully automated, continuous deployment pipeline engineered for zero-maintenance overhead and maximum performance.</p>

      <p>Here is the technical deep-dive into how this platform operates, from source code to edge delivery.</p>

      <h2>1. The Core Philosophy: "Source" vs "Distribution"</h2>
      <p>Most developers mix their source code and their build artifacts in a single repository. I treat my portfolio like enterprise software.</p>

      <h3>The Problem</h3>
      <p>GitHub Pages serves static content. Modern web development (React, TypeScript, Vite) requires a build step. Managing build artifacts (<code>dist/</code> or <code>build/</code>) in the same repo as source code pollutes the git history and creates merge conflicts.</p>

      <h3>The Solution: Repository Separation</h3>
      <p>I architected a Dual-Repository Strategy:</p>
      <ul>
        <li><strong>The Source Core (Private Logic):</strong> The brain. Contains the raw TypeScript, React components, Vite configuration, and the "Invisible Engine" logic.</li>
        <li><strong>The Distribution Layer (Public Edge):</strong> The body. A dumb, clean repository that contains <em>only</em> the optimized, minified production assets generated by the build pipeline.</li>
      </ul>
      <p>This separation ensures that the public-facing identity is purely the optimized output, while the proprietary logic and source history remain encapsulated.</p>

      <h2>2. The Frontend Stack: React + Vite + Framer Motion</h2>
      <p>The user interface isn't just "styled"; it's a state-driven application.</p>

      <h3>A. The "Auto-Theme" State Machine</h3>
      <p>I implemented a custom React hook that acts as a finite state machine for the theme:</p>
      <ul>
        <li><strong>States:</strong> <code>AUTO</code> | <code>DAY</code> | <code>NIGHT</code></li>
        <li><strong>Trigger:</strong> Scroll Position (<code>window.scrollY</code>) & User Override.</li>
      </ul>
      <p>When in <code>auto</code> mode, the application listens to the scroll position using Framer Motion's <code>useScroll</code>.</p>
      <ul>
        <li><strong>0px - Threshold:</strong> The system simulates "Day Mode" (Light theme, welcoming message).</li>
        <li><strong>{'&gt;'}Threshold:</strong> The system transitions to "Night Mode" (Dark theme, terminal aesthetic), symbolizing the "descent" into the backend machinery where the real work happens.</li>
      </ul>

      <pre><code>{`// The logic behind the "descent"
useMotionValueEvent(scrollY, "change", (latest) => {
  if (themeMode === 'auto') {
    const shouldBeNight = latest > THRESHOLD
    // Triggers a React state update only when the threshold is crossed
    if (shouldBeNight !== (effectiveTheme === 'night')) {
      setEffectiveTheme(shouldBeNight ? 'night' : 'day')
    }
  }
})`}</code></pre>

      <h3>B. Sticky Parallax Architecture</h3>
      <p>To make the theme transition impactful, I engineered a <strong>Sticky Hero Section</strong>.</p>
      <ul>
        <li><strong>The Problem:</strong> As you scroll to trigger the theme change, the content naturally moves <em>out</em> of view. The user misses the transition.</li>
        <li><strong>The Engineering:</strong> I utilized CSS <code>position: sticky</code> combined with a calculated container height (<code>160vh</code>).
          <ol>
            <li>The hero content "sticks" to the top of the viewport for the first 60% of the scroll duration.</li>
            <li>The user scrolls <em>physically</em>, but visually the content remains static.</li>
            <li>During this "stasis", the theme engine swaps the CSS variables and text content (<code>AnimatePresence</code> handles the cross-fade).</li>
            <li>Only after the transition completes does the sticky container release, allowing natural scrolling to resume.</li>
          </ol>
        </li>
      </ul>

      <h2>3. The Orchestration: GitHub Actions CI/CD</h2>
      <p>Changes are deployed automatically. I do not manually build or upload files. The pipeline is defined in a standard GitHub Actions workflow file.</p>

      <h3>The Pipeline Flow</h3>
      <p>Every time code is pushed to the <code>main</code> branch of the source repository, the following automated sequence triggers:</p>
      <ol>
        <li><strong>Environment Provisioning (Ubuntu Latest):</strong> A clean Linux container is spun up. The latest source code is pulled.</li>
        <li><strong>Dependency Resolution (Node.js):</strong> <code>npm ci</code> (Clean Install) is used instead of <code>npm install</code>. This forces the pipeline to adhere strictly to the <code>package-lock.json</code>, ensuring deterministic builds.</li>
        <li><strong>The Build Phase (Vite):</strong> <code>npm run build</code> triggers Vite.
          <ul>
            <li><strong>TypeScript Compilation (<code>tsc -b</code>):</strong> Verifies type safety. If there's a type error, the build fails immediately.</li>
            <li><strong>Bundling (Rollup):</strong> Code is tree-shaken, minified, and split into chunks for optimal loading.</li>
            <li><strong>Asset Optimization:</strong> CSS is extracted and optimized. <code>dist/</code> folder is generated.</li>
          </ul>
        </li>
        <li><strong>Cross-Repository Deployment:</strong> This is the critical step. The pipeline uses an <strong>SSH Deploy Key</strong> to authenticate with the separate <em>public</em> repository. It pushes the contents of the <code>dist/</code> folder to the <code>main</code> branch of the distribution repo.</li>
      </ol>

      <pre><code>{`- name: Deploy to Distribution Repo
  uses: peaceiris/actions-gh-pages@v3
  with:
    deploy_key: \${{ secrets.DEPLOY_KEY }}
    external_repository: <target-repo>
    publish_branch: main
    publish_dir: ./dist`}</code></pre>

      <h2>4. The Governance: AI with Guardrails</h2>
      <p>While this platform leverages advanced AI for rapid prototyping and code generation, I do not blindly trust the output. "Trust but Verify" is the core tenet of my engineering workflow.</p>

      <h3>The Rulebook</h3>
      <p>My AI collaborators operate under a strict <strong>System Protocol</strong>. This isn't just a prompt; it's a binding contract that adheres to my specific engineering standards:</p>
      <ul>
        <li><strong>No Hallucinations:</strong> Dependencies are cross-referenced against <code>package.json</code> before import.</li>
        <li><strong>Type Safety:</strong> The AI is forbidden from using <code>any</code>. All props and states must be strictly typed.</li>
        <li><strong>Defensive Coding:</strong> System correctness takes precedence over speed.</li>
      </ul>

      <h3>The Verification Layer</h3>
      <p>Even with these rules, the CI/CD pipeline acts as the final judge.</p>
      <ol>
        <li><strong>Static Analysis:</strong> The build process (<code>tsc -b</code>) performs a full type-check. If the AI hallucinates a non-existent prop or messes up a generic, the build fails <em>before</em> deployment.</li>
        <li><strong>Linting as Law:</strong> Unused variables or imports—common artifacts of AI code generation—trigger build failures. The code must be clean to ship.</li>
        <li><strong>Visual Confirmation:</strong> I personally review the visual output in a staging environment (local Vite server) to catch regression that compilers miss.</li>
      </ol>

      <p>This "Symbiotic Workflow" allows me to move at the speed of AI while maintaining the stability of a Senior Engineer.</p>

      <h2>5. The result: Zero-Touch Delivery</h2>
      <ol>
        <li>I write code in VS Code (or collaborate with AI).</li>
        <li>I <code>git push</code>.</li>
        <li><strong>2 minutes later:</strong> The global CDN is updated with the new version.</li>
      </ol>
      <p>This architecture allows me to iterate rapidly. I can tweak a CSS variable for the theme, push the commit, and have it live worldwide without ever touching a server, FTP client, or manual build tool.</p>
      <p>It is concise, it is automated, and it is the standard to which I hold all my engineering projects.</p>

    </BlogPostLayout>
  );
};

export default ArchitecturePost;
